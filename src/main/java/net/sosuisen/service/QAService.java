package net.sosuisen.service;

import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.openai.OpenAiEmbeddingModel;
import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
import dev.langchain4j.store.embedding.EmbeddingSearchResult;
import dev.langchain4j.store.embedding.inmemory.InMemoryEmbeddingStore;
import jakarta.annotation.PostConstruct;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import net.sosuisen.model.Document;
import net.sosuisen.model.SummaryDAO;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Comparator;

@ApplicationScoped
@NoArgsConstructor(force = true)
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class QAService {
    private static final String qaStorePath = "qa_store.json";

    private final SummaryDAO summaryDAO;

    private InMemoryEmbeddingStore<TextSegment> embeddingStore;
    private OpenAiEmbeddingModel model;

    @PostConstruct
    public void init() {
        embeddingStore = VectorStoreLoader.load(qaStorePath);
        model = OpenAiEmbeddingModel.builder()
                .apiKey(System.getenv("OPENAI_API_KEY"))
                .modelName("text-embedding-3-small")
                .build();
    }

    public ArrayList<Document> query(String query, int maxQADocs, double threshold) throws SQLException {
        var segment = TextSegment.from(query);
        var embedding = model.embed(segment).content();

        // To handle cases where there are multiple QAs with the same score, retrieve a larger number than maxQADocs.
        EmbeddingSearchRequest request = new EmbeddingSearchRequest(embedding, maxQADocs + 7, threshold, null);
        EmbeddingSearchResult<TextSegment> result = embeddingStore.search(request);
        if (result.matches().isEmpty()) {
            return null;
        } else {
            var documents = new ArrayList<Document>();
            var prevScore = 0.0d;
            for (var match : result.matches()) {
                var score = match.score();
                if (prevScore != score && documents.size() >= maxQADocs) {
                    break;
                }
                var question = match.embedded().text();
                var answer = match.embedded().metadata().getString("answer");
                var positionTag = match.embedded().metadata().getString("position_tag");
                var context = question + "\n" + answer;
                // Also add a summary of the paragraph generated by the QA to the context.
                var summary = summaryDAO.get(positionTag);
                if (summary != null) {
                    context += "\n" + summary.getSummary();
                }

                documents.add(new Document("qa",
                        positionTag,
                        match.embedded().metadata().getString("position_name"),
                        match.embedded().metadata().getString("section_title"),
                        context,
                        score));
                prevScore = score;
            }
            // Documents are sorted in descending order by score and in ascending order by position tag.
            documents.sort(
                    Comparator.comparingDouble(Document::getScore).reversed()
                            .thenComparing(Document::getPositionName)
            );
            return documents;
        }
    }

}
